## Codebase Patterns
- Dashboard nginx reverse-proxies `/api/` and `/auth/` to `bot:8080`; all other routes serve `index.html` (SPA fallback)
- YouTube search: `AudioResolver.search(query, max_results=5)` uses `ytsearch{n}:` prefix; returns list of dicts with title, url, duration, thumbnail
- Injectable resolver in search handler via `_resolver_factory=None` kwarg (same pattern as `_http_session_factory` in auth.py)
- Search handler falls back to Music cog's `._resolver` if bot/cog available, else creates fresh `AudioResolver()`
- API endpoint handlers access the bot via `request.app.get("bot")`; bot is stored in app via `app["bot"] = bot` in `create_app(bot=bot)`
- FakeApplication in tests/conftest.py supports dict-style access (`app["key"]`, `app.get("key")`) for storing bot reference
- New HTTP exception stubs (FakeHTTPBadRequest, FakeHTTPServiceUnavailable) follow same pattern: subclass FakeHTTPException with `reason` kwarg
- Python test environment: `/tmp/bot-venv/bin/python` with `PYTHONPATH=/tmp/pypackages:/workspace`
- Run tests: `PYTHONPATH=/tmp/pypackages:/workspace /tmp/bot-venv/bin/python -m pytest /workspace/tests/ -v`
- No network access in the container — use lazy imports and sys.modules stubs for packages not in bot-venv
- Integration tests mock discord via conftest.py in `tests/integration/` using sys.modules injection
- For missing packages (like aiohttp, jwt), inject stubs into sys.modules before importing bot modules in tests
- bot/__main__.py pattern: use `asyncio.run(_run(token))` with async _run() to start multiple services alongside bot
- Use lazy imports (`import X  # noqa: PLC0415` inside functions) to defer package requirements to runtime
- Shared aiohttp/jwt stubs live in `tests/conftest.py` (root-level); test files import from there to avoid stub conflicts when multiple files are collected
- For aiohttp async context managers in tests, use `@asynccontextmanager` + `yield` pattern instead of MagicMock.__aenter__ (more reliable)
- When multiple test files stub the same sys.module, use `sys.modules.setdefault` in conftest.py only, then import from sys.modules in test files
- `except SomeClass:` fails in tests when SomeClass is a MagicMock — always use real exception subclasses in stubs
- For injectable HTTP sessions, add `_http_session_factory=None` kwarg to handlers; production code falls back to `aiohttp.ClientSession`

# Ralph Progress Log
Started: Sat Feb 28 10:43:17 PST 2026
---

## 2026-02-28 - US-001
- Implemented aiohttp HTTP API server embedded in bot process
- Added `aiohttp>=3.9` to `pyproject.toml` dependencies
- Created `bot/api/__init__.py` and `bot/api/server.py` with `create_app()` and `start_api_server()`
- Updated `bot/__main__.py` to use async `_run()` pattern starting aiohttp server alongside discord bot
- Added `tests/test_api_server.py` with 9 tests; all 152 tests pass
- Files changed: `pyproject.toml`, `bot/__main__.py`, `bot/api/__init__.py`, `bot/api/server.py`, `tests/test_api_server.py`
- **Learnings for future iterations:**
  - No network access in devcontainer — can't install packages via pip; must use lazy imports + sys.modules stubs in tests
  - Python env is at `/tmp/bot-venv/bin/python`; pytest is in `/tmp/pypackages`
  - Lazy imports (inside functions) let modules load without requiring package installed, defer errors to call time
  - Pattern for aiohttp-less tests: inject fake classes into sys.modules before importing bot.api modules
---

## 2026-02-28 - US-002
- Implemented Discord OAuth2 authentication in the API
- Created `bot/api/auth.py` with: `encode_jwt`/`decode_jwt`, `handle_auth_discord`, `handle_auth_callback`, `handle_auth_me`, `handle_auth_logout`, `make_jwt_middleware`, `setup_auth_routes`
- Updated `bot/api/server.py` to wire in JWT middleware and auth routes via `create_app()`
- Added `PyJWT>=2.0` to `pyproject.toml` dependencies
- Created `tests/conftest.py` (root-level) with shared aiohttp/jwt stubs — prevents stub conflicts when multiple test files collected
- Updated `tests/test_api_server.py` to use shared stubs from conftest
- Added `tests/test_auth.py` with 23 tests covering all auth routes and middleware; all 175 tests pass
- Files changed: `bot/api/auth.py` (new), `bot/api/server.py`, `pyproject.toml`, `tests/conftest.py` (new), `tests/test_api_server.py`, `tests/test_auth.py` (new), `scripts/prd.json` (recreated), `tasks/prd-web-dashboard.md` (staged)
- **Learnings for future iterations:**
  - `handle_auth_callback` uses injectable `_http_session_factory` kwarg for testing; production defaults to `aiohttp.ClientSession`
  - Avoid `except aiohttp.web.HTTPException: raise` when using MagicMock stubs — use flag variables or restructure to avoid catching your own raises
  - `@asynccontextmanager` + `yield` is more reliable for mocking `async with session.post(...) as resp:` than setting `__aenter__`/`__aexit__` on MagicMock
  - All shared stubs (aiohttp, jwt) belong in `tests/conftest.py`; test files import from there
---

## 2026-02-28 - US-004
- Implemented YouTube search API endpoint (`GET /api/search?q={query}&limit={n}`)
- Added `AudioResolver.search(query, max_results=5)` to `bot/audio/resolver.py` — uses `ytsearch{n}:` prefix with yt_dlp, returns list of dicts with title, url, duration, thumbnail
- Created `bot/api/search.py` with `handle_search` and `setup_search_routes`; handler uses Music cog's `._resolver` if available, else creates fresh `AudioResolver()`
- Updated `bot/api/server.py` to import and register search routes via `setup_search_routes(app)`
- Added 7 tests in `tests/unit/test_resolver.py` for `AudioResolver.search()`; added 15 tests in `tests/test_search_api.py`; all 227 tests pass
- Files changed: `bot/audio/resolver.py`, `bot/api/search.py` (new), `bot/api/server.py`, `tests/unit/test_resolver.py`, `tests/test_search_api.py` (new)
- **Learnings for future iterations:**
  - `handle_search` uses `_resolver_factory=None` kwarg for test injection; production uses Music cog resolver or creates fresh AudioResolver
  - limit param is clamped to [1, 25] to prevent abuse; default is 5
  - yt_dlp search returns `{"entries": [...]}` — search() handles None info and missing optional fields gracefully
---

## 2026-02-28 - US-003
- Implemented queue and playback API endpoints in `bot/api/player.py`
- Routes: GET /api/queue, POST /api/queue/skip, POST /api/queue/clear, GET /api/playback, POST /api/playback/pause, POST /api/playback/resume, POST /api/playback/stop
- Updated `bot/api/server.py` to accept `bot` param (stored as `app["bot"]`) and register player routes via `setup_player_routes(app)`
- Updated `bot/__main__.py` to pass `bot=bot` to `create_app()`
- Updated `tests/conftest.py`: added dict-style access to `FakeApplication` (`__setitem__`, `__getitem__`, `get`); added `FakeHTTPBadRequest` and `FakeHTTPServiceUnavailable` exception stubs; registered them in `mock_web`
- Added `tests/test_player_api.py` with 30 tests; all 205 tests pass
- Files changed: `bot/api/player.py` (new), `bot/api/server.py`, `bot/__main__.py`, `tests/conftest.py`, `tests/test_player_api.py` (new)
- **Learnings for future iterations:**
  - Bot is injected into the aiohttp app via `app["bot"] = bot`; handlers read it with `request.app.get("bot")` (returns None if not set)
  - For "Music cog not available" guard, handlers raise `HTTPServiceUnavailable`; for bad input (missing guild_id, wrong state), raise `HTTPBadRequest`
  - Skip delegates to `music._play_next(guild_id)` after `vm.stop()` — same logic as the Discord `/skip` command
  - Stop calls `vm.stop()`, `queue.clear()`, sets `music._current_tracks[guild_id] = None`, then `await vm.leave()`
---

## 2026-02-28 - US-005
- Added `dashboard/` service to Docker Compose for full-stack deployment
- Created `dashboard/Dockerfile` — nginx:alpine serving static files from `/usr/share/nginx/html`
- Created `dashboard/nginx.conf` — listens on port 80; reverse-proxies `/api/` and `/auth/` to `bot:8080`; SPA fallback (`try_files`) for all other routes
- Created `dashboard/index.html` — minimal placeholder (`<div id="root">`) until React app is scaffolded in US-006
- Updated `docker-compose.yml`: `bot` service uses `expose: 8080` (internal); `dashboard` service builds from `./dashboard`, maps `3000:80`, `depends_on: bot`
- Updated `.env.example` with: `API_PORT`, `DISCORD_CLIENT_ID`, `DISCORD_CLIENT_SECRET`, `DISCORD_REDIRECT_URI`, `JWT_SECRET`
- All 227 existing tests still pass
- Files changed: `dashboard/Dockerfile` (new), `dashboard/nginx.conf` (new), `dashboard/index.html` (new), `docker-compose.yml`, `.env.example`
- **Learnings for future iterations:**
  - Docker Compose default network allows services to reach each other by service name (e.g., `http://bot:8080`)
  - `expose:` in Compose makes the port available to sibling services only (not host); `ports:` maps to host
  - US-006 should replace `dashboard/index.html` with the Vite React build output and update `dashboard/Dockerfile` to a multi-stage build
---
